!(function(e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(
        exports,
        require("@babel/runtime/helpers/defineProperty"),
        require("@babel/runtime/helpers/typeof"),
        require("vue")
      )
    : "function" == typeof define && define.amd
    ? define([
        "exports",
        "@babel/runtime/helpers/defineProperty",
        "@babel/runtime/helpers/typeof",
        "vue"
      ], t)
    : t(
        ((e = "undefined" != typeof globalThis ? globalThis : e || self)[
          "vue-mapbox"
        ] = {}),
        e._defineProperty,
        e._typeof,
        e.vue
      );
})(this, function(e, t, r, n) {
  "use strict";
  function o(e) {
    return e && "object" == typeof e && "default" in e ? e : { default: e };
  }
  var i = o(t),
    a = o(r);
  function s(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function c(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? s(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : s(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var u = {
      methods: {
        $_emitEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$emit(e, c({ map: this.map, component: this }, t));
        },
        $_emitMapEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitEvent(e.type, c({ mapboxEvent: e }, t));
        }
      }
    },
    p = {
      resize: { name: "resize" },
      webglcontextlost: { name: "webglcontextlost" },
      webglcontextrestored: { name: "webglcontextrestored" },
      remove: { name: "remove" },
      movestart: { name: "movestart" },
      load: { name: "load" },
      contextmenu: { name: "contextmenu" },
      dblclick: { name: "dblclick" },
      click: { name: "click" },
      touchcancel: { name: "touchcancel" },
      touchmove: { name: "touchmove" },
      touchend: { name: "touchend" },
      touchstart: { name: "touchstart" },
      dataloading: { name: "dataloading" },
      mousemove: { name: "mousemove" },
      mouseup: { name: "mouseup" },
      mousedown: { name: "mousedown" },
      sourcedataloading: { name: "sourcedataloading" },
      error: { name: "error" },
      data: { name: "data" },
      styledata: { name: "styledata" },
      sourcedata: { name: "sourcedata" },
      mouseout: { name: "mouseout" },
      styledataloading: { name: "styledataloading" },
      moveend: { name: "moveend" },
      move: { name: "move" },
      render: { name: "render" },
      zoom: { name: "zoom" },
      zoomstart: { name: "zoomstart" },
      zoomend: { name: "zoomend" },
      boxzoomstart: { name: "boxzoomstart" },
      boxzoomcancel: { name: "boxzoomcancel" },
      boxzoomend: { name: "boxzoomend" },
      rotate: { name: "rotate" },
      rotatestart: { name: "rotatestart" },
      rotateend: { name: "rotateend" },
      dragend: { name: "dragend" },
      drag: { name: "drag" },
      dragstart: { name: "dragstart" },
      pitch: { name: "pitch" },
      idle: { name: "idle" }
    },
    l = {
      container: {
        type: [String, HTMLElement],
        default: function() {
          return "map-".concat(("" + Math.random()).split(".")[1]);
        }
      },
      accessToken: { type: String, default: void 0 },
      minZoom: { type: Number, default: 0 },
      maxZoom: { type: Number, default: 22 },
      mapStyle: { type: [String, Object], required: !0 },
      hash: { type: [Boolean, String], default: !1 },
      interactive: { type: Boolean, default: !0 },
      bearingSnap: { type: Number, default: 7 },
      pitchWithRotate: { type: Boolean, default: !0 },
      clickTolerance: { type: Number, default: 3 },
      attributionControl: { type: Boolean, default: !0 },
      customAttribution: { type: [String, Array], default: null },
      logoPosition: {
        type: String,
        default: "bottom-left",
        validator: function(e) {
          return [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ].includes(e);
        }
      },
      failIfMajorPerformanceCaveat: { type: Boolean, default: !1 },
      preserveDrawingBuffer: { type: Boolean, default: !1 },
      refreshExpiredTiles: { type: Boolean, default: !0 },
      maxBounds: { type: Array, default: function() {} },
      scrollZoom: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      boxZoom: { type: Boolean, default: !0 },
      dragRotate: { type: Boolean, default: !0 },
      dragPan: { type: Boolean, default: !0 },
      keyboard: { type: Boolean, default: !0 },
      doubleClickZoom: { type: Boolean, default: !0 },
      touchZoomRotate: {
        type: [Boolean, Object],
        default: function() {
          return !0;
        }
      },
      trackResize: { type: Boolean, default: !0 },
      center: { type: [Object, Array], default: void 0 },
      zoom: { type: Number, default: 0 },
      bearing: { type: Number, default: 0 },
      pitch: { type: Number, default: 0 },
      bounds: { type: [Object, Array], default: void 0 },
      fitBoundsOptions: { type: Object, default: void 0 },
      renderWorldCopies: { type: Boolean, default: !0 },
      RTLTextPluginUrl: { type: String, default: void 0 },
      light: { type: Object, default: void 0 },
      tileBoundaries: { type: Boolean, default: !1 },
      collisionBoxes: { type: Boolean, default: !1 },
      repaint: { type: Boolean, default: !1 },
      transformRequest: { type: Function, default: null },
      maxTileCacheSize: { type: Number, default: null },
      localIdeographFontFamily: { type: String, default: null },
      collectResourceTiming: { type: Boolean, default: !1 },
      fadeDuration: { type: Number, default: 300 },
      crossSourceCollisions: { type: Boolean, default: !0 }
    },
    d = {
      maxBounds: function(e) {
        this.map.setMaxBounds(e);
      },
      minZoom: function(e) {
        this.map.setMinZoom(e);
      },
      maxZoom: function(e) {
        this.map.setMaxZoom(e);
      },
      mapStyle: function(e) {
        this.map.setStyle(e);
      },
      collisionBoxes: function(e) {
        this.map.showCollisionBoxes = e;
      },
      tileBoundaries: function(e) {
        this.map.showTileBoundaries = e;
      },
      repaint: function(e) {
        this.map.repaint = e;
      },
      zoom: function(e) {
        this.map.setZoom(e);
      },
      center: function(e) {
        this.map.setCenter(e);
      },
      bearing: function(e) {
        this.map.setBearing(e);
      },
      pitch: function(e) {
        this.map.setPitch(e);
      },
      light: function(e) {
        this.map.setLigh(e);
      }
    };
  function h(e, t, r, n) {
    var o = this;
    this.initial ||
      (this.$attrs["onUpdate:".concat(e)]
        ? (this.propsIsUpdating[e]
            ? ((this._watcher.active = !1),
              this.$nextTick(function() {
                o._watcher.active = !0;
              }))
            : ((this._watcher.active = !0), t(r, n)),
          (this.propsIsUpdating[e] = !1))
        : t(r, n));
  }
  var m,
    f = {
      watch:
        ((m = {}),
        Object.entries(d).forEach(function(e) {
          m[e[0]] = function(t, r) {
            return h.call(this, e[0], e[1].bind(this), t, r);
          };
        }),
        m)
    };
  function y(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function g(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? y(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : y(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function b(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function v(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? b(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : b(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var O = {
      events: [
        {
          name: "moveend",
          check: function(e, t) {
            return t.center && e.isMoving();
          }
        },
        {
          name: "zoomend",
          check: function(e, t) {
            return void 0 !== t.zoom && null !== t.zoom && e.isZooming();
          }
        },
        {
          name: "rotateend",
          check: function(e, t) {
            return void 0 !== t.bearing && null !== t.bearing && e.isRotating();
          }
        },
        {
          name: "pitchend",
          check: function(e, t) {
            return void 0 !== t.pitch && null !== t.bearing && e.isMoving();
          }
        }
      ],
      getter: function(e) {
        return {
          center: e.getCenter(),
          zoom: e.getZoom(),
          bearing: e.getBearing(),
          pitch: e.getPitch()
        };
      }
    },
    j = {
      events: [
        {
          name: "moveend",
          check: function(e) {
            return e.isMoving();
          }
        }
      ],
      getter: function(e) {
        return { center: e.getCenter() };
      }
    },
    $ = {
      events: [
        {
          name: "zoomend",
          check: function(e) {
            return e.isZooming();
          }
        }
      ],
      getter: function(e) {
        return { zoom: e.getZoom() };
      }
    },
    P = {
      events: [
        {
          name: "rotateend",
          check: function(e) {
            return e.isRotating();
          }
        }
      ],
      getter: function(e) {
        return { bearing: e.getBearing() };
      }
    },
    w = {
      setCenter: j,
      panBy: j,
      panTo: j,
      setZoom: $,
      zoomTo: $,
      zoomIn: $,
      zoomOut: $,
      setBearing: P,
      rotateTo: P,
      resetNorth: P,
      snapToNorth: P,
      setPitch: {
        events: [
          {
            name: "pitchend",
            check: function(e) {
              return !0;
            }
          }
        ],
        getter: function(e) {
          return { pitch: e.getPitch() };
        }
      },
      fitBounds: {
        events: [
          {
            name: "zoomend",
            check: function(e) {
              return e.isZooming();
            }
          },
          {
            name: "moveend",
            check: function(e) {
              return e.isMoving();
            }
          },
          {
            name: "rotateend",
            check: function(e) {
              return e.isRotating();
            }
          }
        ],
        getter: function(e) {
          return {
            zoom: e.getZoom(),
            bearing: e.getBearing(),
            pitch: e.getPitch(),
            center: e.getCenter()
          };
        }
      },
      fitScreenCoordinates: {
        events: [
          {
            name: "zoomend",
            check: function(e, t) {
              return e.isZooming();
            }
          },
          {
            name: "moveend",
            check: function(e, t) {
              return e.isMoving();
            }
          },
          {
            name: "rotateend",
            check: function(e, t) {
              return t.bearing && e.isRotating();
            }
          }
        ],
        getter: function(e) {
          return {
            zoom: e.getZoom(),
            center: e.getCenter(),
            bearing: e.getBearing(),
            pitch: e.getPitch()
          };
        }
      },
      jumpTo: O,
      easeTo: O,
      flyTo: O
    };
  function S(e) {
    return "".concat(e, "-").concat(("" + Math.random()).split(".")[1]);
  }
  function _(e, t, r, n) {
    return function o(i) {
      i.type === t && i.eventId === r && (e.off(t, o), n(i));
    };
  }
  function E(e, t) {
    var r = e[t],
      n = r.length;
    return function() {
      for (
        var o = [],
          i = { eventId: S(t) },
          s = w[t].events.map(function(t, r) {
            return {
              event: t,
              func: new Promise(function(n, a) {
                (o[r] = { event: t, func: _(e, t.name, i.eventId, n) }),
                  e.on(t.name, o[r].func);
              })
            };
          }),
          c = [],
          u = 0;
        u < n;
        u++
      )
        u === n - 1
          ? c.push(
              v(
                v({}, i),
                (u < 0 || arguments.length <= u ? void 0 : arguments[u]) || {}
              )
            )
          : c.push(
              (u < 0 || arguments.length <= u ? void 0 : arguments[u]) || null
            );
      var p = [],
        l = (arguments.length <= 0 ? void 0 : arguments[0]) || {};
      try {
        r.apply(e, c),
          "fitBounds" === t && (l = {}),
          "fitScreenCoordinates" === t &&
            (((l = { bearing: null }).bearing = null),
            "number" ==
              typeof (arguments.length <= 2 ? void 0 : arguments[2]) &&
              (l.bearing = arguments.length <= 2 ? void 0 : arguments[2]),
            (arguments.length <= 3 ? void 0 : arguments[3]) &&
              "object" ===
                a.default(arguments.length <= 3 ? void 0 : arguments[3]) &&
              (l = v(v({}, l), arguments.length <= 3 ? void 0 : arguments[3]))),
          (p = s.map(function(t) {
            var r = t.event,
              n = t.func;
            return r.check(e, l) ? n : (e.off(r.name, n), Promise.resolve());
          }));
      } catch (t) {
        throw (o.forEach(function(t) {
          var r = t.event,
            n = t.func;
          e.off(r.name, n);
        }),
        t);
      }
      return Promise.all(p).then(function() {
        return w[t].getter(e);
      });
    };
  }
  function I(e) {
    var t = Object.keys(w),
      r = {};
    return (
      t.forEach(function(n) {
        -1 !== t.indexOf(n) && (r[n] = E(e, n));
      }),
      r
    );
  }
  function L(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function x(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? L(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : L(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function k(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  var M = {
    name: "GlMap",
    mixins: [
      f,
      {
        created: function() {
          this.actions = {};
        },
        methods: {
          $_registerAsyncActions: function(e) {
            this.actions = x(
              x(
                {},
                (function(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : null;
                  return t ? E(e, t) : I(e);
                })(e)
              ),
              {},
              {
                stop: function() {
                  var e = this;
                  this.map.stop();
                  var t = {
                    pitch: this.map.getPitch(),
                    zoom: this.map.getZoom(),
                    bearing: this.map.getBearing(),
                    center: this.map.getCenter()
                  };
                  return (
                    Object.entries(t).forEach(function(t) {
                      e.$_updateSyncedPropsFabric(t[0], t[1])();
                    }),
                    Promise.resolve(t)
                  );
                }
              }
            );
          }
        }
      },
      {
        methods: {
          $_updateSyncedPropsFabric: function(e, t) {
            var r = this;
            return function() {
              r.propsIsUpdating[e] = !0;
              var n = "function" == typeof t ? t() : t;
              return r.$emit("update:".concat(e), n);
            };
          },
          $_bindPropsUpdateEvents: function() {
            var e = this;
            [
              {
                events: ["moveend"],
                prop: "center",
                getter: this.map.getCenter.bind(this.map)
              },
              {
                events: ["zoomend"],
                prop: "zoom",
                getter: this.map.getZoom.bind(this.map)
              },
              {
                events: ["rotate"],
                prop: "bearing",
                getter: this.map.getBearing.bind(this.map)
              },
              {
                events: ["pitch"],
                prop: "pitch",
                getter: this.map.getPitch.bind(this.map)
              },
              {
                events: ["moveend", "zoomend", "rotate", "pitch"],
                prop: "bounds",
                getter: function() {
                  var t = e.map.getBounds();
                  return (
                    e.$props.bounds instanceof Array && (t = t.toArray()), t
                  );
                }
              }
            ].forEach(function(t) {
              var r = t.events,
                n = t.prop,
                o = t.getter;
              r.forEach(function(t) {
                e.$attrs["onUpdate:".concat(n)] &&
                  e.map.on(t, e.$_updateSyncedPropsFabric(n, o));
              });
            });
          },
          $_loadMap: function() {
            var e = this;
            return this.mapboxPromise.then(function(t) {
              return (
                (e.mapbox = t.default ? t.default : t),
                new Promise(function(t) {
                  e.accessToken && (e.mapbox.accessToken = e.accessToken);
                  var r = new e.mapbox.Map(
                    g(
                      g({}, e._props),
                      {},
                      { container: e.$refs.container, style: e.mapStyle }
                    )
                  );
                  r.on("load", function() {
                    return t(r);
                  });
                })
              );
            });
          },
          $_RTLTextPluginError: function(e) {
            this.$emit("rtl-plugin-error", { map: this.map, error: e });
          },
          $_bindMapEvents: function(e) {
            var t = this;
            Object.keys(this.$attrs).forEach(function(r) {
              r.startsWith("on") &&
                e.includes(r) &&
                t.map.on(r, t.$_emitMapEvent);
            });
          },
          $_unbindEvents: function(e) {
            var t = this;
            e.forEach(function(e) {
              t.map.off(e, t.$_emitMapEvent);
            });
          }
        }
      },
      u
    ],
    props: (function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? k(Object(r), !0).forEach(function(t) {
              i.default(e, t, r[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : k(Object(r)).forEach(function(t) {
              Object.defineProperty(
                e,
                t,
                Object.getOwnPropertyDescriptor(r, t)
              );
            });
      }
      return e;
    })({ mapboxGl: { type: Object, default: null } }, l),
    provide: function() {
      var e = this;
      return {
        get mapbox() {
          return e.mapbox;
        },
        get map() {
          return e.map;
        },
        get actions() {
          return e.actions;
        }
      };
    },
    data: function() {
      return { initial: !0, initialized: !1, $_containerVNode: null };
    },
    computed: {
      loaded: function() {
        return !!this.map && this.map.loaded();
      },
      version: function() {
        return this.map ? this.map.version : null;
      },
      isStyleLoaded: function() {
        return !!this.map && this.map.isStyleLoaded();
      },
      areTilesLoaded: function() {
        return !!this.map && this.map.areTilesLoaded();
      },
      isMoving: function() {
        return !!this.map && this.map.isMoving();
      },
      canvas: function() {
        return this.map ? this.map.getCanvas() : null;
      },
      canvasContainer: function() {
        return this.map ? this.map.getCanvasContainer() : null;
      },
      images: function() {
        return this.map ? this.map.listImages() : null;
      }
    },
    created: function() {
      (this.map = null),
        (this.propsIsUpdating = {}),
        (this.$_containerVNode = null),
        (this.mapboxPromise = this.mapboxGl
          ? Promise.resolve(this.mapboxGl)
          : import("mapbox-gl"));
    },
    mounted: function() {
      var e = this;
      this.$_loadMap().then(function(t) {
        (e.map = t),
          void 0 !== e.RTLTextPluginUrl &&
            "loaded" !== e.mapbox.getRTLTextPluginStatus() &&
            e.mapbox.setRTLTextPlugin(
              e.RTLTextPluginUrl,
              e.$_RTLTextPluginError
            );
        var r = Object.keys(p);
        e.$_bindMapEvents(r),
          e.$_registerAsyncActions(t),
          e.$_bindPropsUpdateEvents(),
          (e.initial = !1),
          (e.initialized = !0),
          e.$emit("load", { map: t, component: e });
      });
    },
    emits: ["load"],
    beforeUnmount: function() {
      var e = this;
      this.$nextTick(function() {
        e.map && e.map.remove();
      });
    },
    render: function() {
      return (
        this.$_containerVNode ||
          (this.$_containerVNode = n.h("div", {
            id: this.container,
            ref: "container"
          })),
        n.h("div", { class: "mgl-map-wrapper" }, [
          this.$_containerVNode,
          this.initialized ? this.$slots.default : null
        ])
      );
    }
  };
  function C(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function D(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? C(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : C(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var B = {
      methods: {
        $_emitSelfEvent: function(e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.$_emitMapEvent(e, D({ control: this.control }, t));
        },
        $_bindSelfEvents: function(e, t) {
          var r = this;
          Object.keys(this.$attrs).forEach(function(n) {
            n.startsWith("on") && e.includes(n) && t.on(n, r.$_emitSelfEvent);
          });
        },
        $_unbindSelfEvents: function(e, t) {
          var r = this;
          0 !== e.length &&
            t &&
            e.forEach(function(e) {
              t.off(e, r.$_emitSelfEvent);
            });
        }
      }
    },
    T = {
      mixins: [u, B],
      inject: ["mapbox", "map", "actions"],
      props: { position: { type: String, default: "top-right" } },
      beforeUnmount: function() {
        this.map && this.control && this.map.removeControl(this.control);
      },
      methods: {
        $_addControl: function() {
          try {
            this.map.addControl(this.control, this.position);
          } catch (e) {
            return void this.$_emitEvent("error", { error: e });
          }
          this.$_emitEvent("added", { control: this.control });
        }
      },
      render: function() {}
    },
    z = {
      name: "NavigationControl",
      mixins: [T],
      props: {
        showCompass: { type: Boolean, default: !0 },
        showZoom: { type: Boolean, default: !0 }
      },
      created: function() {
        (this.control = new this.mapbox.NavigationControl(this.$props)),
          this.$_addControl();
      }
    },
    F = {
      trackuserlocationstart: "trackuserlocationstart",
      trackuserlocationend: "trackuserlocationend",
      geolocate: "geolocate",
      error: "error"
    },
    Z = {
      name: "GeolocateControl",
      mixins: [u, B, T],
      props: {
        positionOptions: {
          type: Object,
          default: function() {
            return { enableHighAccuracy: !1, timeout: 6e3 };
          }
        },
        fitBoundsOptions: {
          type: Object,
          default: function() {
            return { maxZoom: 15 };
          }
        },
        trackUserLocation: { type: Boolean, default: !1 },
        showUserLocation: { type: Boolean, default: !0 }
      },
      created: function() {
        var e = this.mapbox.GeolocateControl;
        (this.control = new e(this.$props)),
          this.$_addControl(),
          this.$_bindSelfEvents(Object.keys(F), this.control);
      },
      methods: {
        trigger: function() {
          if (this.control) return this.control.trigger();
        }
      }
    },
    R = {
      name: "FullscreenControl",
      mixins: [T],
      props: { container: { type: HTMLElement, default: void 0 } },
      created: function() {
        (this.control = new this.mapbox.FullscreenControl(this.$props)),
          this.$_addControl();
      }
    },
    A = {
      name: "AttributionControl",
      mixins: [T],
      props: {
        compact: { type: Boolean, default: !0 },
        customAttribution: { type: [String, Array], deafault: void 0 }
      },
      created: function() {
        (this.control = new this.mapbox.AttributionControl(this.$props)),
          this.$_addControl();
      }
    },
    N = {
      name: "ScaleControl",
      mixins: [T],
      props: {
        maxWidth: { type: Number, default: 150 },
        unit: {
          type: String,
          default: "metric",
          validator: function(e) {
            return ["imperial", "metric", "nautical"].includes(e);
          }
        }
      },
      watch: {
        unit: function(e, t) {
          this.control && e !== t && this.control.setUnit(e);
        }
      },
      created: function() {
        (this.control = new this.mapbox.ScaleControl(this.$props)),
          this.$_addControl();
      }
    };
  function U(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  var q = { drag: "drag", dragstart: "dragstart", dragend: "dragend" },
    V = { click: "click", mouseenter: "mouseenter", mouseleave: "mouseleave" },
    G = {
      name: "MapMarker",
      mixins: [u, B],
      inject: ["mapbox", "map"],
      provide: function() {
        var e = this;
        return {
          get marker() {
            return e.marker;
          }
        };
      },
      props: {
        offset: {
          type: [Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array, required: !0 },
        color: { type: String },
        anchor: { type: String, default: "center" },
        draggable: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, marker: void 0 };
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.marker.setLngLat(e);
        },
        draggable: function(e) {
          this.initial || this.marker.setDraggable(e);
        }
      },
      mounted: function() {
        var e = this,
          t = (function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? U(Object(r), !0).forEach(function(t) {
                    i.default(e, t, r[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(r)
                  )
                : U(Object(r)).forEach(function(t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(r, t)
                    );
                  });
            }
            return e;
          })({}, this.$props);
        this.$slots.marker && (t.element = this.$slots.marker[0].elm),
          (this.marker = new this.mapbox.Marker(t)),
          this.$atts["onUpdate:coordinates"] &&
            this.marker.on("dragend", function(t) {
              var r;
              (r =
                e.coordinates instanceof Array
                  ? [t.target._lngLat.lng, t.target._lngLat.lat]
                  : t.target._lngLat),
                e.$emit("update:coordinates", r);
            });
        var r = Object.keys(q);
        this.$_bindSelfEvents(r, this.marker),
          (this.initial = !1),
          this.$_addMarker();
      },
      beforeUnmount: function() {
        void 0 !== this.map && void 0 !== this.marker && this.marker.remove();
      },
      methods: {
        $_addMarker: function() {
          this.marker.setLngLat(this.coordinates).addTo(this.map),
            this.$_bindMarkerDOMEvents(),
            this.$_emitEvent("added", { marker: this.marker });
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { marker: this.marker });
        },
        $_bindMarkerDOMEvents: function() {
          var e = this;
          Object.keys(this.$attrs).forEach(function(t) {
            t.startsWith("on") &&
              Object.values(V).includes(t) &&
              e.marker._element.addEventListener(t, function(t) {
                e.$_emitSelfEvent(t);
              });
          });
        },
        remove: function() {
          this.marker.remove(), this.$_emitEvent("removed");
        },
        togglePopup: function() {
          return this.marker.togglePopup();
        }
      },
      render: function() {
        return n.h("div", { style: { display: "none" } }, [
          this.$slots.marker,
          this.marker ? this.$slots.default : null
        ]);
      }
    },
    W = { open: "open", close: "close" },
    H = {
      name: "Popup",
      mixins: [u, B],
      inject: {
        mapbox: { default: null },
        map: { default: null },
        marker: { default: null }
      },
      props: {
        closeButton: { type: Boolean, default: !0 },
        closeOnClick: { type: Boolean, default: !0 },
        anchor: {
          validator: function(e) {
            return (
              "string" == typeof e &&
              [
                "top",
                "bottom",
                "left",
                "right",
                "top-left",
                "top-right",
                "bottom-left",
                "bottom-right"
              ].includes(e)
            );
          },
          default: void 0
        },
        offset: {
          type: [Number, Object, Array],
          default: function() {
            return [0, 0];
          }
        },
        coordinates: { type: Array },
        onlyText: { type: Boolean, default: !1 },
        showed: { type: Boolean, default: !1 }
      },
      data: function() {
        return { initial: !0, popup: void 0 };
      },
      computed: {
        open: {
          get: function() {
            return void 0 !== this.popup && this.popup.isOpen();
          },
          set: function(e) {
            this.map &&
              this.popup &&
              (e ? this.popup.addTo(this.map) : this.popup.remove());
          }
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.popup.setLngLat(e);
        },
        showed: function(e, t) {
          e !== t &&
            ((this.open = e), this.marker && this.marker.togglePopup());
        }
      },
      created: function() {
        this.popup = new this.mapbox.Popup(this.$props);
      },
      mounted: function() {
        this.$_addPopup(), (this.initial = !1);
      },
      beforeUnmount: function() {
        this.map && (this.popup.remove(), this.$_emitEvent("removed"));
      },
      methods: {
        $_addPopup: function() {
          if (
            ((this.popup = new this.mapbox.Popup(this.$props)),
            void 0 !== this.coordinates &&
              this.popup.setLngLat(this.coordinates),
            void 0 !== this.$slots.default)
          )
            if (this.onlyText)
              if (3 === this.$slots.default[0].elm.nodeType) {
                var e = document.createElement("span");
                e.appendChild(this.$slots.default[0].elm),
                  this.popup.setText(e.innerText);
              } else this.popup.setText(this.$slots.default[0].elm.innerText);
            else this.popup.setDOMContent(this.$slots.default[0].elm);
          this.$_bindSelfEvents(Object.keys(W), this.popup),
            this.$_emitEvent("added", { popup: this.popup }),
            this.marker && this.marker.setPopup(this.popup),
            this.showed &&
              ((this.open = !0), this.marker && this.marker.togglePopup());
        },
        $_emitSelfEvent: function(e) {
          this.$_emitMapEvent(e, { popup: this.popup });
        },
        remove: function() {
          this.popup.remove(),
            this.$_emitEvent("remove", { popup: this.popup });
        }
      },
      render: function() {
        return n.h("div", { style: { display: "none" } }, [
          this.$slots.default
        ]);
      }
    },
    J = [
      "mousedown",
      "mouseup",
      "click",
      "dblclick",
      "mousemove",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "contextmenu",
      "touchstart",
      "touchend",
      "touchcancel"
    ];
  function K(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function Q(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? K(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : K(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var X = {
      layerId: { type: String, required: !0 },
      layer: { type: Object, required: !0 },
      before: { type: String, default: void 0 }
    },
    Y = {
      clearSource: { type: Boolean, default: !0 },
      replaceSource: { type: Boolean, default: !1 },
      replace: { type: Boolean, default: !1 }
    },
    ee = {
      mixins: [u],
      props: Q(
        Q(
          Q(
            {},
            {
              sourceId: { type: String, required: !0 },
              source: { type: [Object, String], default: void 0 }
            }
          ),
          X
        ),
        Y
      ),
      inject: ["mapbox", "map"],
      data: function() {
        return { initial: !0 };
      },
      computed: {
        sourceLoaded: function() {
          return !!this.map && this.map.isSourceLoaded(this.sourceId);
        },
        mapLayer: function() {
          return this.map ? this.map.getLayer(this.layerId) : null;
        },
        mapSource: function() {
          return this.map ? this.map.getSource(this.sourceId) : null;
        }
      },
      created: function() {
        this.layer.minzoom &&
          this.$watch("layer.minzoom", function(e) {
            this.initial ||
              this.map.setLayerZoomRange(this.layerId, e, this.layer.maxzoom);
          }),
          this.layer.maxzoom &&
            this.$watch("layer.maxzoom", function(e) {
              this.initial ||
                this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, e);
            }),
          this.layer.paint &&
            this.$watch(
              "layer.paint",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var n = r[t];
                    this.map.setPaintProperty(this.layerId, n, e[n]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.layout &&
            this.$watch(
              "layer.layout",
              function(e) {
                if (!this.initial && e)
                  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
                    var n = r[t];
                    this.map.setLayoutProperty(this.layerId, n, e[n]);
                  }
              },
              { deep: !0 }
            ),
          this.layer.filter &&
            this.$watch(
              "layer.filter",
              function(e) {
                this.initial || this.map.setFilter(this.layerId, e);
              },
              { deep: !0 }
            );
      },
      beforeUnmount: function() {
        if (this.map && this.map.loaded()) {
          try {
            this.map.removeLayer(this.layerId);
          } catch (e) {
            this.$_emitEvent("layer-does-not-exist", {
              layerId: this.sourceId,
              error: e
            });
          }
          if (this.clearSource)
            try {
              this.map.removeSource(this.sourceId);
            } catch (e) {
              this.$_emitEvent("source-does-not-exist", {
                sourceId: this.sourceId,
                error: e
              });
            }
        }
      },
      methods: {
        $_emitLayerMapEvent: function(e) {
          return this.$_emitMapEvent(e, { layerId: this.layerId });
        },
        $_bindLayerEvents: function(e) {
          var t = this;
          Object.keys(this.$attrs).forEach(function(r) {
            r.startsWith("on") &&
              e.includes(r) &&
              t.map.on(r, t.layerId, t.$_emitLayerMapEvent);
          });
        },
        $_unbindEvents: function(e) {
          var t = this;
          this.map &&
            e.forEach(function(e) {
              t.map.off(e, t.layerId, t.$_emitLayerMapEvent);
            });
        },
        $_watchSourceLoading: function(e) {
          "source" === e.dataType &&
            e.sourceId === this.sourceId &&
            (this.$_emitEvent("layer-source-loading", {
              sourceId: this.sourceId
            }),
            this.map.off("dataloading", this.$_watchSourceLoading));
        },
        move: function(e) {
          this.map.moveLayer(this.layerId, e),
            this.$_emitEvent("layer-moved", {
              layerId: this.layerId,
              beforeId: e
            });
        },
        remove: function() {
          this.map.removeLayer(this.layerId),
            this.map.removeSource(this.sourceId),
            this.$_emitEvent("layer-removed", { layerId: this.layerId }),
            this.$destroy();
        }
      },
      render: function() {}
    };
  function te(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function re(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? te(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : te(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function ne(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function oe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? ne(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : ne(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function ie(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function ae(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? ie(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : ie(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function se(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function ce(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? se(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : se(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function ue(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function pe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? ue(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : ue(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  function le(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t &&
        (n = n.filter(function(t) {
          return Object.getOwnPropertyDescriptor(e, t).enumerable;
        })),
        r.push.apply(r, n);
    }
    return r;
  }
  function de(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {};
      t % 2
        ? le(Object(r), !0).forEach(function(t) {
            i.default(e, t, r[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : le(Object(r)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
          });
    }
    return e;
  }
  var he = u,
    me = B,
    fe = T,
    ye = ee,
    ge = { withEvents: u, withSelfEvents: B, asControl: T, asLayer: ee },
    be = M,
    ve = z,
    Oe = Z,
    je = R,
    $e = A,
    Pe = N,
    we = {
      name: "GeojsonLayer",
      mixins: [ee],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, { filter: t })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        },
        getClusterExpansionZoom: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, n) {
              if (!e.mapSource)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              e.mapSource.getClusterExpansionZoom(t, function(e, t) {
                return e ? n(e) : r(t);
              });
            });
          };
        },
        getClusterChildren: function() {
          var e = this;
          return function(t) {
            return new Promise(function(r, n) {
              var o = e.mapSource;
              if (!o)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              o.getClusterChildren(t, function(e, t) {
                return e ? n(e) : r(t);
              });
            });
          };
        },
        getClusterLeaves: function() {
          var e = this;
          return function() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
              r[n] = arguments[n];
            return new Promise(function(t, n) {
              if (!e.mapSource)
                return n(
                  new Error(
                    "Map source with id ".concat(e.sourceId, " not found.")
                  )
                );
              var o;
              (o = e.mapSource).getClusterLeaves.apply(
                o,
                r.concat([
                  function(e, r) {
                    return e ? n(e) : t(r);
                  }
                ])
              );
            });
          };
        }
      },
      created: function() {
        this.source &&
          this.$watch(
            "source.data",
            function(e) {
              this.initial || this.mapSource.setData(e);
            },
            { deep: !0 }
          ),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          if (
            (this.map.on("dataloading", this.$_watchSourceLoading), this.source)
          ) {
            var e = re({ type: "geojson" }, this.source);
            try {
              this.map.addSource(this.sourceId, e);
            } catch (t) {
              this.replaceSource &&
                (this.map.removeSource(this.sourceId),
                this.map.addSource(this.sourceId, e));
            }
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(J),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = re({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = { id: e, source: this.source };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = { id: e, source: this.source };
            return this.map.getFeatureState(t);
          }
        },
        removeFeatureState: function(e, t, r) {
          if (this.map) {
            var n = { id: e, source: this.source, sourceLayer: t };
            return this.map.removeFeatureState(n, r);
          }
        }
      }
    },
    Se = {
      name: "ImageLayer",
      mixins: [ee],
      created: function() {
        this.source &&
          (this.source.coordinates &&
            this.$watch(
              "source.coordinates",
              function(e) {
                this.initial || (e && this.mapSource.setCoordinates(e));
              },
              { deep: !0 }
            ),
          this.source.url &&
            this.$watch(
              "source.url",
              function(e) {
                this.initial ||
                  (e &&
                    this.mapSource.updateImage({
                      url: e,
                      coordinates: this.source.coordinates
                    }));
              },
              { deep: !0 }
            )),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = oe({ type: "image" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(J), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = oe(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    _e = {
      name: "CanvasLayer",
      mixins: [ee],
      inject: ["mapbox", "map"],
      props: {
        source: { type: Object, required: !0 },
        layer: { type: Object, default: null }
      },
      computed: {
        canvasElement: function() {
          return this.mapSource ? this.mapSource.getCanvas() : null;
        }
      },
      watch: {
        coordinates: function(e) {
          this.initial || this.mapSource.setCoordinates(e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = ae({ type: "canvas" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(J), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = ae(
            { id: this.layerId, source: this.sourceId, type: "raster" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", {
              layerId: this.layerId,
              canvas: this.canvasElement
            });
        }
      }
    },
    Ee = {
      name: "VideoLayer",
      mixins: [ee],
      computed: {
        video: function() {
          return this.map.getSource(this.sourceId).getVideo();
        }
      },
      created: function() {
        this.source &&
          this.source.coordinates &&
          this.$watch("source.coordinates", function(e) {
            this.initial || this.mapSource.setCoordinates(e);
          }),
          this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = ce({ type: "video" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(), this.$_bindLayerEvents(J), (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = ce(
            { id: this.layerId, source: this.sourceId, type: "background" },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    Ie = {
      name: "VectorLayer",
      mixins: [ee],
      computed: {
        getSourceFeatures: function() {
          var e = this;
          return function(t) {
            return e.map
              ? e.map.querySourceFeatures(e.sourceId, {
                  sourceLayer: e.layer["source-layer"],
                  filter: t
                })
              : null;
          };
        },
        getRenderedFeatures: function() {
          var e = this;
          return function(t, r) {
            return e.map
              ? e.map.queryRenderedFeatures(t, {
                  layers: [e.layerId],
                  filter: r
                })
              : null;
          };
        }
      },
      watch: {
        filter: function(e) {
          this.initial || this.map.setFilter(this.layerId, e);
        }
      },
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = pe({ type: "vector" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(J),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = pe({ id: this.layerId, source: this.sourceId }, this.layer);
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        },
        setFeatureState: function(e, t) {
          if (this.map) {
            var r = {
              id: e,
              source: this.sourceId,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.setFeatureState(r, t);
          }
        },
        getFeatureState: function(e) {
          if (this.map) {
            var t = {
              id: e,
              source: this.source,
              "source-layer": this.layer["source-layer"]
            };
            return this.map.getFeatureState(t);
          }
        }
      }
    },
    Le = {
      name: "RasterLayer",
      mixins: [ee],
      created: function() {
        this.$_deferredMount();
      },
      methods: {
        $_deferredMount: function() {
          var e = de({ type: "raster" }, this.source);
          this.map.on("dataloading", this.$_watchSourceLoading);
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
          this.$_addLayer(),
            this.$_bindLayerEvents(J),
            this.map.off("dataloading", this.$_watchSourceLoading),
            (this.initial = !1);
        },
        $_addLayer: function() {
          var e = this.map.getLayer(this.layerId);
          if (e) {
            if (!this.replace)
              return (
                this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
              );
            this.map.removeLayer(this.layerId);
          }
          var t = de(
            { id: this.layerId, type: "raster", source: this.sourceId },
            this.layer
          );
          this.map.addLayer(t, this.before),
            this.$_emitEvent("added", { layerId: this.layerId });
        }
      }
    },
    xe = G,
    ke = H;
  (e.$helpers = ge),
    (e.MglAttributionControl = $e),
    (e.MglCanvasLayer = _e),
    (e.MglFullscreenControl = je),
    (e.MglGeojsonLayer = we),
    (e.MglGeolocateControl = Oe),
    (e.MglImageLayer = Se),
    (e.MglMap = be),
    (e.MglMarker = xe),
    (e.MglNavigationControl = ve),
    (e.MglPopup = ke),
    (e.MglRasterLayer = Le),
    (e.MglScaleControl = Pe),
    (e.MglVectorLayer = Ie),
    (e.MglVideoLayer = Ee),
    (e.asControl = fe),
    (e.asLayer = ye),
    (e.withEvents = he),
    (e.withSelfEvents = me),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
